"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[4795],{3276:(e,r,a)=>{a.r(r),a.d(r,{Tag:()=>l,assets:()=>i,contentTitle:()=>o,default:()=>p,frontMatter:()=>t,metadata:()=>n,toc:()=>s});const n=JSON.parse('{"id":"api-class-reference/utility/CharacterLoadedWrapper","title":"CharacterLoadedWrapper","description":"CharacterLoadedWrapper - special wrapper for Player which tracks Character\'s state.","source":"@site/docs/api-class-reference/utility/CharacterLoadedWrapper.md","sourceDirName":"api-class-reference/utility","slug":"/api-class-reference/utility/CharacterLoadedWrapper","permalink":"/RetroBoxDocs/docs/api-class-reference/utility/CharacterLoadedWrapper","draft":false,"unlisted":false,"editUrl":"https://github.com/NOPESbucket/RetroBox/edit/main/docs/api-class-reference/utility/CharacterLoadedWrapper.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"apiSidebar","previous":{"title":"CharacterBuilder","permalink":"/RetroBoxDocs/docs/api-class-reference/utility/CharacterBuilder"},"next":{"title":"Component","permalink":"/RetroBoxDocs/docs/api-class-reference/utility/Component"}}');var d=a(4848),c=a(8453);const t={sidebar_position:5},o=void 0,i={},l=({children:e,color:r})=>(0,d.jsx)("span",{style:{fontSize:"0.75em",backgroundColor:r,borderRadius:"4px",color:"#fff",padding:"0.2rem 0.5rem",fontWeight:"bold"},children:e}),s=[{value:"Properties",id:"properties",level:2},{value:"&gt; <code>Loaded: Signal.Signal&lt;Model&gt;</code> <Tag>Public</Tag>",id:"-loaded-signalsignalmodel-public",level:3},{value:"&gt; <code>Died: Signal.Signal&lt;Model&gt;</code> <Tag>Public</Tag>",id:"-died-signalsignalmodel-public",level:3},{value:"&gt; <code>_player: Player</code> <Tag>Private</Tag>",id:"-_player-player-private",level:3},{value:"&gt; <code>_destroyed: boolean</code> <Tag>Private</Tag>",id:"-_destroyed-boolean-private",level:3},{value:"&gt; <code>_connections: { RBXScriptConnection }</code> <Tag>Private</Tag>",id:"-_connections--rbxscriptconnection--private",level:3},{value:"Constructor",id:"constructor",level:2},{value:"&gt; <code>CharacterLoadedWrapper.new(player: Player)</code>",id:"-characterloadedwrappernewplayer-player",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>CharacterLoadedWrapper:IsLoaded(optionalCharacter: Model?): boolean</code> <Tag>Public</Tag>",id:"characterloadedwrapperisloadedoptionalcharacter-model-boolean-public",level:3},{value:"<code>CharacterLoadedWrapper:_listenForCharacterAdded(): ()</code> <Tag>Private</Tag>",id:"characterloadedwrapper_listenforcharacteradded--private",level:3},{value:"<code>CharacterLoadedWrapper:_waitForLoadedAsync(character: Model): ()</code> <Tag>Private</Tag>",id:"characterloadedwrapper_waitforloadedasynccharacter-model--private",level:3},{value:"<code>CharacterLoadedWrapper:_listenForDeath(character: Model): ()</code> <Tag>Private</Tag>",id:"characterloadedwrapper_listenfordeathcharacter-model--private",level:3},{value:"<code>CharacterLoadedWrapper:Destroy(): ()</code> <Tag>Public</Tag>",id:"characterloadedwrapperdestroy--public",level:3}];function h(e){const r={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(r.p,{children:["CharacterLoadedWrapper - special wrapper for Player which tracks Character's state.\r\nThis differs from ",(0,d.jsx)(r.code,{children:"Player.CharacterAdded"})," and ",(0,d.jsx)(r.code,{children:"Player.CharacterAppearanceLoaded"})," which fire\r\nbefore a character is parented to workspace and does not guarantee these other conditions.\r\nWe need this because there are some cases where a character can be removed without the humanoid dying,\r\nsuch as if ",(0,d.jsx)(r.code,{children:":LoadCharacter()"})," is called before a character dies. Cleanup code often needs to run when a\r\ncharacter's ",(0,d.jsx)(r.strong,{children:"lifespan"})," is over, whether it be because the humanoid died or because the character is removed.\r\nTo avoid having to connect to both events in multiple places, this wrapper moves both events into one."]}),"\n",(0,d.jsx)(r.admonition,{type:"info",children:(0,d.jsx)(r.p,{children:"This is a preffered workflow, because the behavior of this wrapper is guaranteed to be consistent and safe."})}),"\n",(0,d.jsx)(r.h2,{id:"properties",children:"Properties"}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"-loaded-signalsignalmodel-public",children:["> ",(0,d.jsx)(r.code,{children:"Loaded: Signal.Signal<Model>"})," ",(0,d.jsx)(l,{color:"#e3ce8b",children:"Public"})]}),"\n",(0,d.jsx)(r.p,{children:"Fires when player's character model is fully loaded."}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"-died-signalsignalmodel-public",children:["> ",(0,d.jsx)(r.code,{children:"Died: Signal.Signal<Model>"})," ",(0,d.jsx)(l,{color:"#e3ce8b",children:"Public"})]}),"\n",(0,d.jsxs)(r.p,{children:["Fires when player's character either ",(0,d.jsx)(r.em,{children:"died"})," or character model was deleted from workspace."]}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"-_player-player-private",children:["> ",(0,d.jsx)(r.code,{children:"_player: Player"})," ",(0,d.jsx)(l,{color:"#4958df",children:"Private"})]}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"-_destroyed-boolean-private",children:["> ",(0,d.jsx)(r.code,{children:"_destroyed: boolean"})," ",(0,d.jsx)(l,{color:"#4958df",children:"Private"})]}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"-_connections--rbxscriptconnection--private",children:["> ",(0,d.jsx)(r.code,{children:"_connections: { RBXScriptConnection }"})," ",(0,d.jsx)(l,{color:"#4958df",children:"Private"})]}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsx)(r.h2,{id:"constructor",children:"Constructor"}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"-characterloadedwrappernewplayer-player",children:["> ",(0,d.jsx)(r.code,{children:"CharacterLoadedWrapper.new(player: Player)"})]}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-lua",metastring:'title="ServerScriptService/PlayerManagment.server.lua"',children:'-- [Packages] --\r\nlocal Modules = game.ReplicatedStorage.Modules\r\n\r\n-- [Modules] --\r\nlocal CharacterLoadedWrapper = require(Modules.Utility.CharacterLoadedWrapper)\r\n\r\n-- [Services] --\r\nlocal Players = game:GetService("Players")\r\n\r\n-- [Functions] --\r\n\r\n-- Create new CharacterLoader which will observe characters state\r\nlocal function onPlayerAdded(player: Player)\r\n    local characterLoader = CharacterLoadedWrapper.new(player)\r\n\r\n    characterLoader.Loaded:Connect(function(character)\r\n        print(`[{script.Name}]: Spawned {character}.`)\r\n    end)\r\n\r\n    characterLoader.Died:Connect(function(character)\r\n        print(`[{script.Name}]: {character} died.`)\r\n    end)\r\nend\r\n\r\n-- [Main] --\r\nfor _, player in Players:GetPlayers() do\r\n    onPlayerAdded(player)\r\nend\r\n\r\nPlayers.PlayerAdded:Connect(onPlayerAdded)\n'})}),"\n",(0,d.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"characterloadedwrapperisloadedoptionalcharacter-model-boolean-public",children:[(0,d.jsx)(r.code,{children:"CharacterLoadedWrapper:IsLoaded(optionalCharacter: Model?): boolean"})," ",(0,d.jsx)(l,{color:"#e3ce8b",children:"Public"})]}),"\n",(0,d.jsx)(r.p,{children:"Returns true if character passes these checks:"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsx)(r.li,{children:"Has PrimaryPart set"}),"\n",(0,d.jsxs)(r.li,{children:["Humanoid is Alive (not in ",(0,d.jsx)(r.code,{children:"Enum.HumanoidStateType.Dead"})," and ",(0,d.jsx)(r.code,{children:"Health"})," > 0)"]}),"\n",(0,d.jsx)(r.li,{children:"Descendant of workspace (indicates that character fully loaded)"}),"\n"]}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"characterloadedwrapper_listenforcharacteradded--private",children:[(0,d.jsx)(r.code,{children:"CharacterLoadedWrapper:_listenForCharacterAdded(): ()"})," ",(0,d.jsx)(l,{color:"#4958df",children:"Private"})]}),"\n",(0,d.jsx)(r.p,{children:"Starts listening for player's character state."}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"characterloadedwrapper_waitforloadedasynccharacter-model--private",children:[(0,d.jsx)(r.code,{children:"CharacterLoadedWrapper:_waitForLoadedAsync(character: Model): ()"})," ",(0,d.jsx)(l,{color:"#4958df",children:"Private"})]}),"\n",(0,d.jsx)(r.p,{children:"Waits asynchronously for player's character to load.\r\nThis function assumes the character exists when it's called and has default behavior,\r\ni.e. developer is not parenting the character somewhere manually."}),"\n",(0,d.jsx)(r.admonition,{type:"warning",children:(0,d.jsx)(r.p,{children:"This method Yields!"})}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"characterloadedwrapper_listenfordeathcharacter-model--private",children:[(0,d.jsx)(r.code,{children:"CharacterLoadedWrapper:_listenForDeath(character: Model): ()"})," ",(0,d.jsx)(l,{color:"#4958df",children:"Private"})]}),"\n",(0,d.jsx)(r.p,{children:"Debounce to prevent deferred events from letting .Died event fire more than once,\r\nsuch as if the humanoid dies and the character is destroyed in the same compute cycle.\r\nWith deferred events, that would fire both events on the next cycle, even if the connection\r\nis disconnected within the response to the event."}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsxs)(r.h3,{id:"characterloadedwrapperdestroy--public",children:[(0,d.jsx)(r.code,{children:"CharacterLoadedWrapper:Destroy(): ()"})," ",(0,d.jsx)(l,{color:"#e3ce8b",children:"Public"})]}),"\n",(0,d.jsx)(r.p,{children:"Destroy's the CharacterLoadedWrapper, releasing it from memory."}),"\n",(0,d.jsx)(r.hr,{})]})}function p(e={}){const{wrapper:r}={...(0,c.R)(),...e.components};return r?(0,d.jsx)(r,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}},8453:(e,r,a)=>{a.d(r,{R:()=>t,x:()=>o});var n=a(6540);const d={},c=n.createContext(d);function t(e){const r=n.useContext(c);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:t(e.components),n.createElement(c.Provider,{value:r},e.children)}}}]);